import got from 'got';
import http from 'http';
import Docker from 'dockerode';
import envVars from './fixtures/envVars-temp.json';
import parseSAMTemplate from './src/parseSAMTemplate';
import createController from './src/controller';
import createDockerService from './src/dockerService';
import { parseFunctionsFromTemplate } from './src/serverlessFunctions';

const PORT = Number(process.env.PORT);

const prepareEnvironment = async (dockerService) => {
  await Promise.all([
    dockerService.killOldContainers(),
    dockerService.pullRequiredDockerImages(),
  ]);

  await dockerService.createContainers();
};

const getEndpoints = (functions) => functions
  .map(({ method, path }) => ({ method: method.toUpperCase(), path: path.full }));

const spinUpServer = (functions) => {
  const server = http.createServer();
  const controller = createController(got, functions);

  server.on('request', controller);

  server.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
    console.log('The following endpoints are exposed:');
    console.table(getEndpoints(functions));
    const cleanUpCommand = `docker rm -f $(docker ps -a -f label=aws-sam-api-proxy.api=${process.env.API_NAME} -q)`;
    console.log(`For killing all containers generated by this script, run the following command - "${cleanUpCommand}"`);
  });
};

async function go() {
  try {
    const docker = new Docker();
    const dockerStatus = await docker.ping();
    if (dockerStatus.toString() !== 'OK') throw new Error('Docker must be running');

    const template = await parseSAMTemplate('./fixtures/template.yaml');

    const portOffset = PORT + 1;
    const functions = parseFunctionsFromTemplate(template, envVars, portOffset);
    const dockerService = createDockerService(docker, functions);

    await prepareEnvironment(dockerService);

    spinUpServer(functions);
  } catch (err) {
    console.log(err);
  }
}

go();
